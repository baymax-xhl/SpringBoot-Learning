# jdk12新特性

## 6.1 switch表达式（预览）
* 使用 Java 12 中 Switch 表达式的写法，省去了 break 语句，避免了因少写 break 而出错。

* 同时将多个 case 合并到一行，显得简洁、清晰也更加优雅的表达逻辑分支，其具体写法就是将之前的 case 语
句表成了：case L ->，即如果条件匹配 case L，则执行标签右侧的代码 ，同时标签右侧的代码段只能是表达
式、代码块或 throw 语句。

* 为了保持兼容性，case 条件语句中依然可以使用字符 : ，这时 fall-through 规则依然有效的，即不能省略原有
的 break 语句，但是同一个 Switch 结构里不能混用 -> 和 : ，否则会有编译错误。并且简化后的 Switch 代码块
中定义的局部变量，其作用域就限制在代码块中，而不是蔓延到整个 Switch 结构，也不用根据不同的判断条件
来给变量赋值

## 6.2 Shenandoah GC：低停顿时间的GC（预览）

### 6.2.1背景和设计思路

针对 JVM 上的内存收回实现低停顿的需求

该设计将与应用程序线程并发，通过交换 CPU 并发周期和空间以改善停顿时间，使得垃圾回收器执行线程能够在 Java 线程运行时进行堆压缩，并且标记和整理能够同时进行，因此避免了在
大多数 JVM 垃圾收集器中所遇到的问题

Shenandoah GC 主要目标是 99.9% 的暂停小于 10ms，暂停与堆大小无关等

### 6.2.2 STW
Stop-the-World

Stop-the-World ，简称STW ，指的是GC 事件发生过程中，停止所有的应用程序线程的执行。就像警察办案，需要
清场一样

垃圾回收器的任务是识别和回收垃圾对象进行内存清理。为了让垃圾回收器可以正常且高效地执行，大部分情况下会
要求系统进入一个停顿的状态。停顿的目的是终止所有应用程序的执行，只有这样，系统中才不会有新的垃圾产生，
同时停顿保证了系统状态在某一个瞬间的一致性，也有益于垃圾回收器更好地标记垃圾对象。因此，在垃圾回收时，
都会产生应用程序的停顿。停顿产生时整个应用程序会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为
STW

如果Stop-the- World 出现在新生代的Minor GC 中时， 由于新生代的内存空间通常都比较小， 所以暂停时间也在可
接受的合理范围之内，不过一旦出现在老年代的Full GC 中时，程序的工作线程被暂停的时间将会更久。简单来说，
内存空间越大，执行Full GC 的时间就会越久， 相对的工作线程被暂停的时间也就会更长

到目前为止，哪怕是G1 也不能完全避免Stop-the-world 情况发生，只能说垃圾回收器越来越优秀，回收效率越来越
高， 尽可能地缩短了暂停时间

### 6.2.3 补充：垃圾收集器的分类

#### 线程
串行、并行

#### 工作模式
并发式、独占式

#### 碎片处理方式
压缩式、非压缩式

#### 工作的内存区间
年轻代、老年代

### 6.2.4 补充：如何评估一款GC的性能
* 吞吐量：程序的运行时间（程序的运行时间＋内存回收的时间）。
* 垃圾收集开销：吞吐量的补数，垃圾收集器所占时间与总时间的比例。
* 暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。
* 收集频率：相对于应用程序的执行，收集操作发生的频率。
* 堆空间： Java 堆区所占的内存大小。
* 快速： 一个对象从诞生到被回收所经历的时间

## 6.3 JVM 常量 API

Java 12 中引入 JVM 常量 API，用来更容易地对关键类文件 (key class-file) 和运行时构件（artefact）的名义描述
(nominal description) 进行建模，特别是对那些从常量池加载的常量，这是一项非常技术性的变化，能够以更简
单、标准的方式处理可加载常量

java.base模块新增了java.lang.constant包,包中定义了一系列基于值的符号引用（JVMS 5.1）类型，它们能够描述每种可加载常量

## 6.4 微基准测试套件
### 6.4.1 何为JMH?

JMH，即Java Microbenchmark Harness，是专门用于代码微基准测试的工具套件。何谓Micro Benchmark呢？简
单的来说就是基于方法层面的基准测试，精度可以达到微秒级。当你定位到热点方法，希望进一步优化方法性能的时
候，就可以使用JMH对优化的结果进行量化的分析。

### 6.4.2 JMH比较典型的应用场景：
* 想准确的知道某个方法需要执行多长时间，以及执行时间和输入之间的相关性；
* 对比接口不同实现在给定条件下的吞吐量；
* 查看多少百分比的请求在多长时间内完成；

### 6.4.3 JMH的使用
要使用JMH，首先需要准备好Maven环境，JMH的源代码以及官方提供的Sample就是使用Maven进行项目管理的，
github上也有使用gradle的例子可自行搜索参考。使用mvn命令行创建一个JMH工程：
如果要在现有Maven项目中使用JMH，只需要把生成出来的两个依赖以及shade插件拷贝到项目的pom中即可：

```shell script
mvn archetype:generate \
-DinteractiveMode=false \
-DarchetypeGroupId=org.openjdk.jmh \
-DarchetypeArtifactId=jmh-java-benchmark-archetype \
-DgroupId=co.speedar.infra \
-DartifactId=jmh-test \
-Dversion=1.0
```

如果要在现有Maven项目中使用JMH，只需要把生成出来的两个依赖以及shade插件拷贝到项目的pom中即可


### 6.4.4 新特性的说明
Java 12 中添加一套新的基本的微基准测试套件（microbenchmarks suite），此功能为JDK源代码添加了一套微基准
测试（大约100个），简化了现有微基准测试的运行和新基准测试的创建过程。使开发人员可以轻松运行现有的微基
准测试并创建新的基准测试，其目标在于提供一个稳定且优化过的基准。 它基于Java Microbenchmark
Harness（JMH），可以轻松测试JDK性能，支持JMH更新。
微基准套件与 JDK 源代码位于同一个目录中，并且在构建后将生成单个 jar 文件。但它是一个单独的项目，在支持构
建期间不会执行，以方便开发人员和其他对构建微基准套件不感兴趣的人在构建时花费比较少的构建时间。
要构建微基准套件，用户需要运行命令：make build-microbenchmark， 类似的命令还有：make test
TEST="micro:java.lang.invoke" 将使用默认设置运行 java.lang.invoke 相关的微基准测试